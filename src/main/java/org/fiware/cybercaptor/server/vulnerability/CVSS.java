/****************************************************************************************
 * This file is part of FIWARE CyberCAPTOR,                                             *
 * instance of FIWARE Cyber Security Generic Enabler                                    *
 * Copyright (C) 2012-2015  Thales Services S.A.S.,                                     *
 * 20-22 rue Grande Dame Rose 78140 VELIZY-VILACOUBLAY FRANCE                           *
 *                                                                                      *
 * FIWARE CyberCAPTOR is free software; you can redistribute                            *
 * it and/or modify it under the terms of the GNU General Public License                *
 * as published by the Free Software Foundation; either version 3 of the License,       *
 * or (at your option) any later version.                                               *
 *                                                                                      *
 * FIWARE CyberCAPTOR is distributed in the hope                                        *
 * that it will be useful, but WITHOUT ANY WARRANTY; without even the implied           *
 * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            *
 * GNU General Public License for more details.                                         *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License                    *
 * along with FIWARE Cyber Security Generic Enabler.                                    *
 * If not, see <http://www.gnu.org/licenses/>.                                          *
 ****************************************************************************************/
package org.fiware.cybercaptor.server.vulnerability;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

/**
 * Class that represents a CVSS (Common Vulnerability Scoring System) attached to a vulnerability CVE
 *
 * @author Francois -Xavier Aguessy
 */
public class CVSS {
    /**
     * The cvss id in the db
     */
    private int id = 0;
    /**
     * The global score
     */
    private double score = 0.;
    /**
     * The access vector value
     */
    private AccessVectorValues accessVector = AccessVectorValues.UNDEFINED;
    /**
     * The access complexity value
     */
    private AccessComplexityValues accessComplexity = AccessComplexityValues.UNDEFINED;
    /**
     * The authentication value
     */
    private AuthenticationValues authentication = AuthenticationValues.UNDEFINED;
    /**
     * The confidentiality impact value
     */
    private ImpactValues confidentialityImpact = ImpactValues.UNDEFINED;
    /**
     * The Integrity impact value
     */
    private ImpactValues integrityImpact = ImpactValues.UNDEFINED;
    /**
     * The Availability impact value
     */
    private ImpactValues availabilityImpact = ImpactValues.UNDEFINED;

    /**
     * The default constructor
     */
    public CVSS() {

    }

    /**
     * Create a cvss from the database
     *
     * @param conn    the database connection
     * @param id_cvss the id of the cvss
     * @throws Exception the exception
     */
    public CVSS(Connection conn, int id_cvss) throws Exception {
        loadFromDatabase(id_cvss, conn);
    }

    /**
     * Gets id.
     *
     * @return the id
     */
    public int getId() {
        return id;
    }

    /**
     * Sets id.
     *
     * @param id the id
     */
    public void setId(int id) {
        this.id = id;
    }

    /**
     * Gets score.
     *
     * @return the score
     */
    public double getScore() {
        return score;
    }

    /**
     * Sets score.
     *
     * @param score the score
     */
    public void setScore(double score) {
        this.score = score;
    }

    /**
     * Gets access vector.
     *
     * @return the access vector
     */
    public AccessVectorValues getAccessVector() {
        return accessVector;
    }

    /**
     * Sets access vector.
     *
     * @param accessVector the access vector
     */
    public void setAccessVector(AccessVectorValues accessVector) {
        this.accessVector = accessVector;
    }

    /**
     * Gets access complexity.
     *
     * @return the access complexity
     */
    public AccessComplexityValues getAccessComplexity() {
        return accessComplexity;
    }

    /**
     * Sets access complexity.
     *
     * @param accessComplexity the access complexity
     */
    public void setAccessComplexity(AccessComplexityValues accessComplexity) {
        this.accessComplexity = accessComplexity;
    }

    /**
     * Gets authentication.
     *
     * @return the authentication
     */
    public AuthenticationValues getAuthentication() {
        return authentication;
    }

    /**
     * Sets authentication.
     *
     * @param authentication the authentication
     */
    public void setAuthentication(AuthenticationValues authentication) {
        this.authentication = authentication;
    }

    /**
     * Gets confidentiality impact.
     *
     * @return the confidentiality impact
     */
    public ImpactValues getConfidentialityImpact() {
        return confidentialityImpact;
    }

    /**
     * Sets confidentiality impact.
     *
     * @param confidentialityImpact the confidentiality impact
     */
    public void setConfidentialityImpact(ImpactValues confidentialityImpact) {
        this.confidentialityImpact = confidentialityImpact;
    }

    /**
     * Gets integrity impact.
     *
     * @return the integrity impact
     */
    public ImpactValues getIntegrityImpact() {
        return integrityImpact;
    }

    /**
     * Sets integrity impact.
     *
     * @param integrityImpact the integrity impact
     */
    public void setIntegrityImpact(ImpactValues integrityImpact) {
        this.integrityImpact = integrityImpact;
    }

    /**
     * Gets availability impact.
     *
     * @return the availability impact
     */
    public ImpactValues getAvailabilityImpact() {
        return availabilityImpact;
    }

    /**
     * Sets availability impact.
     *
     * @param availabilityImpact the availability impact
     */
    public void setAvailabilityImpact(ImpactValues availabilityImpact) {
        this.availabilityImpact = availabilityImpact;
    }

    /**
     * Load a vulnerability from the database with an id
     *
     * @param id_cvss The id of the cvss
     * @param conn    The Database connection
     * @return true if the cvss was in the database, else false
     * @throws java.sql.SQLException the sQL exception
     */
    public boolean loadFromDatabase(int id_cvss, Connection conn) throws SQLException {
        if (id_cvss <= 0) {
            return false;
        }
        PreparedStatement pstmt = conn.prepareStatement("SELECT * FROM cvss WHERE id = ?");
        pstmt.setInt(1, id_cvss);
        pstmt.execute();
        ResultSet res = pstmt.getResultSet();
        if (res.next()) {
            setId(res.getInt(1));
            setScore(res.getDouble(2));
            setAccessVector(AccessVectorValues.fromString(res.getString(3)));
            setAccessComplexity(AccessComplexityValues.fromString(res.getString(4)));
            setAuthentication(AuthenticationValues.fromString(res.getString(5)));
            setConfidentialityImpact(ImpactValues.fromString(res.getString(6)));
            setIntegrityImpact(ImpactValues.fromString(res.getString(7)));
            setAvailabilityImpact(ImpactValues.fromString(res.getString(8)));
            res.close();
            return true;

        } else {
            return false;
        }
    }

    /**
     * Add the cvss to the database
     *
     * @param conn the database connection
     * @throws java.sql.SQLException the sQL exception
     */
    public void addToDatabase(Connection conn) throws SQLException {
        PreparedStatement pstmt = conn.prepareStatement("INSERT INTO cvss(score,access_vector,access_complexity,authentication,confidentiality_impact,integrity_impact,availability_impact) VALUES(?,?,?,?,?,?,?)");
        pstmt.setDouble(1, getScore());
        pstmt.setString(2, getAccessVector().toString().toUpperCase());
        pstmt.setString(3, getAccessComplexity().toString().toUpperCase());
        pstmt.setString(4, getAuthentication().toString().toUpperCase());
        pstmt.setString(5, getConfidentialityImpact().toString().toUpperCase());
        pstmt.setString(6, getIntegrityImpact().toString().toUpperCase());
        pstmt.setString(7, getAvailabilityImpact().toString().toUpperCase());
        pstmt.execute();
        ResultSet resultSetId = pstmt.getGeneratedKeys();
        setId(resultSetId.getInt(1));
        resultSetId.close();
    }

    /**
     * The enum Access vector values.
     */
    public enum AccessVectorValues {
        /**
         * UNDEFINED.
         */
        UNDEFINED, /**
         * NETWORK.
         */
        NETWORK, /**
         * ADJACENT.
         */
        ADJACENT, /**
         * LOCAL.
         */
        LOCAL;

        /**
         * From string.
         *
         * @param s the s
         * @return the access vector values
         */
        public static AccessVectorValues fromString(String s) {
            if (s.toUpperCase().equals("NETWORK")) {
                return NETWORK;
            } else if (s.toUpperCase().equals("ADJACENT")) {
                return ADJACENT;
            } else if (s.toUpperCase().equals("LOCAL")) {
                return LOCAL;
            }
            return UNDEFINED;
        }
    }

    /**
     * The enum Access complexity values.
     */
    public enum AccessComplexityValues {
        /**
         * UNDEFINED.
         */
        UNDEFINED, /**
         * LOW.
         */
        LOW, /**
         * MEDIUM.
         */
        MEDIUM, /**
         * HIGH.
         */
        HIGH;

        /**
         * From string.
         *
         * @param s the s
         * @return the access complexity values
         */
        public static AccessComplexityValues fromString(String s) {
            if (s.toUpperCase().equals("LOW")) {
                return LOW;
            } else if (s.toUpperCase().equals("MEDIUM")) {
                return MEDIUM;
            } else if (s.toUpperCase().equals("HIGH")) {
                return HIGH;
            }
            return UNDEFINED;
        }
    }

    /**
     * The enum Authentication values.
     */
    public enum AuthenticationValues {
        /**
         * UNDEFINED.
         */
        UNDEFINED, /**
         * MULTIPLE.
         */
        MULTIPLE, /**
         * SINGLE.
         */
        SINGLE, /**
         * NONE.
         */
        NONE;

        /**
         * From string.
         *
         * @param s the s
         * @return the authentication values
         */
        public static AuthenticationValues fromString(String s) {
            if (s.toUpperCase().equals("MULTIPLE")) {
                return MULTIPLE;
            } else if (s.toUpperCase().equals("SINGLE")) {
                return SINGLE;
            } else if (s.toUpperCase().equals("NONE")) {
                return NONE;
            }
            return UNDEFINED;
        }
    }

    /**
     * The enum Impact values.
     */
    public enum ImpactValues {
        /**
         * UNDEFINED.
         */
        UNDEFINED, /**
         * NONE.
         */
        NONE, /**
         * PARTIAL.
         */
        PARTIAL, /**
         * COMPLETE.
         */
        COMPLETE;

        /**
         * From string.
         *
         * @param s the s
         * @return the impact values
         */
        public static ImpactValues fromString(String s) {
            if (s.toUpperCase().equals("NONE")) {
                return NONE;
            } else if (s.toUpperCase().equals("PARTIAL")) {
                return PARTIAL;
            } else if (s.toUpperCase().equals("COMPLETE")) {
                return COMPLETE;
            }
            return UNDEFINED;
        }
    }
}
