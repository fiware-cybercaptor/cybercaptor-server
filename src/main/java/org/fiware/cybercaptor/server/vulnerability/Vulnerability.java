/****************************************************************************************
 * This file is part of FIWARE CyberCAPTOR,                                             *
 * instance of FIWARE Cyber Security Generic Enabler                                    *
 * Copyright (C) 2012-2015  Thales Services S.A.S.,                                     *
 * 20-22 rue Grande Dame Rose 78140 VELIZY-VILACOUBLAY FRANCE                           *
 *                                                                                      *
 * FIWARE CyberCAPTOR is free software; you can redistribute                            *
 * it and/or modify it under the terms of the GNU General Public License                *
 * as published by the Free Software Foundation; either version 3 of the License,       *
 * or (at your option) any later version.                                               *
 *                                                                                      *
 * FIWARE CyberCAPTOR is distributed in the hope                                        *
 * that it will be useful, but WITHOUT ANY WARRANTY; without even the implied           *
 * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            *
 * GNU General Public License for more details.                                         *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License                    *
 * along with FIWARE Cyber Security Generic Enabler.                                    *
 * If not, see <http://www.gnu.org/licenses/>.                                          *
 ****************************************************************************************/
package org.fiware.cybercaptor.server.vulnerability;

import org.fiware.cybercaptor.server.remediation.Patch;
import org.fiware.cybercaptor.server.remediation.Rule;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;


/**
 * Class that represent a vulnerability
 * @author Francois-Xavier Aguessy
 *
 */
public class Vulnerability {
	/**
	 * The pattern of a CVE id
	 */
	public final static Pattern PATTERN = Pattern.compile("^[a-zA-Z]{1,5}-\\d{4}-\\d+$");
	
	/**
	 * The id of the vulnerability in the database
	 */
	public int id = 0;
	
	/**
	 * The CVE of the vulnerability on the following format : "CVE-2000-0000"
	 */
	public String cve= new String();
	
	/**
	 * The description of the vulnerability
	 */
	public String description = new String();
	
	/**
	 * Exploit type (remote exploit, ...)
	 */
	public String exploitType = "";
	
	/**
	 * Exploit goal (privilege escalation, ...)
	 */
	public String exploitGoal = "";
	
	/**
	 * The cvss related to this vulnerability
	 */
	public CVSS cvss = new CVSS();
	
	/**
	 * Default constructor
	 * @param id The id of the vulnerability in the database
	 * @param cve The CVE of the vulnerability on the following format : "CVE-2000-0000"
	 * @param description The description of the vulnerability
	 */
	public Vulnerability(int id, String cve, String description) {
		super();
		this.id = id;
		this.cve = cve;
		this.description = description;
	}

	/**
	 * Create a vulnerability from the database
	 * @param id_vulnerability the id of the vulnerability
	 * @param conn the database connection
	 * @throws Exception
	 */
	public Vulnerability(Connection conn,int id_vulnerability) throws Exception {
		loadFromDatabase(id_vulnerability,conn);
	}
	
	/**
	 * @param cve the CVE
	 * @throws Exception
	 */
	public Vulnerability(String cve) throws Exception {
		Matcher matcherCVE = Vulnerability.PATTERN.matcher(cve);
		if(!matcherCVE.matches()) {
			this.description = cve;
			this.cve = "";
		}
		else {
			this.cve = cve;
		}
	}
	
	/**
	 * Get all vulnerabilities of the database
	 * @param conn the database connection
	 * @return The list of all vulnerabilities
	 * @throws Exception
	 */
	public static List<Vulnerability> getAllVulnerabilities(Connection conn) throws Exception {
		List<Vulnerability> result = new ArrayList<Vulnerability>();
		PreparedStatement pstmt = conn.prepareStatement("SELECT * FROM vulnerability");
		pstmt.execute();
		ResultSet res = pstmt.getResultSet();
		while(res.next()) { //Get all the vulnerabilities
			Vulnerability vulnerability = new Vulnerability(res.getInt(1),res.getString(2),res.getString(3));
			result.add(vulnerability);
		}
		return result;
	}

	/**
	 * Get the id of the vulnerability related to a CVE
	 * @param cve the cve string
	 * @param conn the database connection
	 * @return the id of the vulnerability
	 * @throws Exception
	 */
	public static int getIdVulnerabilityFromCVE(String cve, Connection conn) throws Exception{
		PreparedStatement pstmt = conn.prepareStatement("SELECT id FROM vulnerability WHERE cve LIKE ?");
		pstmt.setString(1,cve);
		pstmt.execute();
		ResultSet res = pstmt.getResultSet();
		boolean found = res.next();
		int result = 0;
		if(found) {
			result = res.getInt(1);
		}
		res.close();
		return result;
	}

	/**
	 * Get all snort rules related to a vulnerability in the Database
	 * @param conn The database Connection
	 * @return a list of the snort rules related to this vulnerability
	 * @throws java.sql.SQLException
	 */
	public List<Rule> getRules(Connection conn) throws SQLException {
		List<Rule> result = new ArrayList<Rule>();
		if(this.inDatabase(conn)) {
			PreparedStatement pstmt = conn.prepareStatement("SELECT id_rule FROM rules_vulnerability WHERE id_vulnerability = ?");
			pstmt.setInt(1,id);
			pstmt.execute();
			ResultSet res = pstmt.getResultSet();
			while(res.next()) { //Get all the rules that are related to this vulnerability
				Rule rule = new Rule(conn, res.getInt(1));
				result.add(rule);
			}
		}
		return result;
	}

	/**
	 * Get all patchs related to a vulnerability from the Database
	 * @param conn The database Connection
	 * @return a list of the patchs related to this vulnerability
	 * @throws java.sql.SQLException
	 */
	public List<Patch> getPatchs(Connection conn) throws SQLException {
		List<Patch> result = new ArrayList<Patch>();
		if(this.inDatabase(conn)) {
			PreparedStatement pstmt = conn.prepareStatement("SELECT id_patch FROM patchs_vulnerability WHERE id_vulnerability = ?");
			pstmt.setInt(1,id);
			pstmt.execute();
			ResultSet res = pstmt.getResultSet();
			while(res.next()) { //Get all the rules that are related to this vulnerability
				Patch patch = new Patch(conn, res.getInt(1));
				result.add(patch);
			}
		}
		return result;
	}

	/**
	 * Find whether or not the vulnerability is in the database and update the object in database
	 * @param conn the database connection
	 * @return true if the vulnerability is in the database, else false
	 * @throws java.sql.SQLException
	 */
	public boolean inDatabase(Connection conn) throws SQLException {
		PreparedStatement pstmt = conn.prepareStatement("SELECT id,cve,description,cvss_id FROM vulnerability WHERE cve LIKE ?");
		pstmt.setString(1,cve);
		pstmt.execute();
		ResultSet res = pstmt.getResultSet();
		boolean result = res.next();
		if(result) { //This CVE is already in the DB
			//We get the id of this vulnerability and update the description
			id = res.getInt(1);
			if((!description.isEmpty() && !description.equals(res.getString(3))) || cvss.getId() != res.getInt(4)) {
				res.close();
				PreparedStatement pstmt2 = conn.prepareStatement("UPDATE vulnerability SET description = ?, cvss_id = ? WHERE id = ?");
				pstmt2.setString(1,description);
				pstmt2.setInt(2, cvss.getId());
				pstmt2.setInt(3,id);
				pstmt2.execute();
				pstmt2.close();
			}
		}
		pstmt.close();
		res.close();
		return result;
	}

	/**
	 * Add the vulnerability to the database
	 * @param conn the database connection
	 * @throws java.sql.SQLException
	 */
	public void addToDatabase(Connection conn) throws SQLException {
		if(!this.inDatabase(conn)) { //This vulnerability is not yet in the DB, so we had it
			PreparedStatement pstmt = conn.prepareStatement("INSERT INTO vulnerability(cve,description,cvss_id) VALUES(?,?,?)");
			pstmt.setString(1,cve);
			pstmt.setString(2,description);
			pstmt.setInt(3, cvss.getId());
			pstmt.execute();
			ResultSet resultSetId = pstmt.getGeneratedKeys();
			id = resultSetId.getInt(1);
			resultSetId.close();
		}
	}

	/**
	 * Add a patch to a vulnerability in the database
	 * @param patch the patch to add to the vulnerability
	 * @param conn the connection to the database
	 * @throws Exception
	 */
	public void addAPatchInDatabase(Patch patch, Connection conn) throws Exception {
		addToDatabase(conn); //We add the vulnerability in the database
		patch.saveToDatabase(conn); //We add the patch in the database

		PreparedStatement pstmt = conn.prepareStatement("REPLACE INTO patchs_vulnerability(id_patch,id_vulnerability) VALUES(?,?)");
		pstmt.setInt(1, patch.getId());
		pstmt.setInt(2,this.id);
		pstmt.execute();
		pstmt.close();

	}

	/**
	 * Add a CPE to a vulnerability in the database
	 * @param cpe the cpe to add to the vulnerability
	 * @param conn the connection to the database
	 * @throws Exception
	 */
	public void addACPEInDatabase(CPE cpe, Connection conn) throws Exception {
		addToDatabase(conn); //We add the vulnerability in the database
		cpe.saveToDatabase(conn); //We add the patch in the database

		PreparedStatement pstmt = conn.prepareStatement("REPLACE INTO cpe_vulnerability(id_cpe,id_vulnerability) VALUES(?,?)");
		pstmt.setInt(1,cpe.id);
		pstmt.setInt(2,this.id);
		pstmt.execute();
		pstmt.close();

	}

	/**
	 * Load a vulnerability from the database with an id
	 * @param conn The Database connection
	 * @param id_vulnerability The id of the vulnerability
	 * @return true if the vulnerability was in the database, else false
	 * @throws java.sql.SQLException
	 */
	public boolean loadFromDatabase(int id_vulnerability,Connection conn) throws SQLException {
		if(id_vulnerability <= 0) {
			return false;
		}
		PreparedStatement pstmt = conn.prepareStatement("SELECT * FROM vulnerability WHERE id = ?");
		pstmt.setInt(1,id_vulnerability);
		pstmt.execute();
		ResultSet res = pstmt.getResultSet();
		if(res.next()) {
			id = res.getInt(1);
			cve = res.getString(2);
			description = res.getString(3);
			int id_cvss = res.getInt(4);
			if(id_cvss > 0)
				cvss.loadFromDatabase(id_cvss, conn);
			res.close();
			return true;

		}
		else {
			return false;
		}
	}
	
	/**
	 * Load all the parameters : id, cvss... (except the CVE) from the database with the cve identifier
	 * @throws java.sql.SQLException
	 */
	public void loadParametersFromDatabase(Connection conn) throws SQLException {
		if(cve.isEmpty() || cve.equals("")) {
			return;
		}
		PreparedStatement pstmt = conn.prepareStatement("SELECT * FROM vulnerability WHERE cve LIKE ?");
		pstmt.setString(1,cve);
		pstmt.execute();
		ResultSet res = pstmt.getResultSet();
		if(res.next()) {
			id = res.getInt(1);
			description = res.getString(3);
			int id_cvss = res.getInt(4);
			if(id_cvss > 0)
				cvss.loadFromDatabase(id_cvss, conn);
			res.close();

		}
	}
	
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((cve == null) ? 0 : cve.hashCode());
		return result;
	}
	
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Vulnerability other = (Vulnerability) obj;
		if (cve == null) {
			if (other.cve != null)
				return false;
		} else if (!cve.equals(other.cve))
			return false;
		return true;
	}

	@Override
	public String toString() {
		return "Vulnerability [cve=" + cve + ", description=" + description +
		", exploitType=" + exploitType + ", exploitGoal=" + exploitGoal
				+ "]";
	}
	
}
